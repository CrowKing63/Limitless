접근성 중심의 뱀파이어 서바이벌류 웹게임 개발 계획

프로젝트 개요
최근 뱀파이어 서바이벌 스타일의 게임을 웹앱으로 구현하여 접근성에 중점을 둔 취미 프로젝트를 시작하고자 합니다. 이 게임은 키보드나 일반 컨트롤러를 사용하기 어려운 사용자를 위해 포인트 앤 클릭(Point-and-Click) 방식의 간소화된 조작을 지원하는 것이 목표입니다. 특히 질문자 본인은 마우스 드래그 등의 지속 입력이 힘든 상황이므로, 클릭 한 번 또는 음성 명령만으로도 플레이할 수 있는 환경을 지향합니다. 또한 Apple Vision Pro와 같은 최신 기기(눈으로 포인트하고 손가락 제스처로 클릭하는 방식)
uploadvr.com
 및 모바일 터치 환경까지 폭넓게 대응하여, 데스크톱/모바일/VR 어디서든 즐길 수 있는 웹게임을 만드는 것을 목표로 합니다. 본 문서에서는 게임 디자인, 조작 방법의 접근성 아이디어, 기술 스택 선정, 개발 단계 계획, 그리고 무료 배포까지의 전반적인 플랜을 제시합니다. 이는 마치 AI 코덱스(Codex)나 AGENTS.md 파일에 프로젝트 명세를 작성하듯 상세하고 체계적으로 구성되었습니다.
접근성 목표 및 고려사항
게임 설계의 최우선 목표는 모든 유저가 자신의 능력에 맞는 방법으로 게임을 조작할 수 있도록 하는 것입니다. 이를 위해 다음과 같은 접근성 원칙을 고려합니다:
다양한 입력 장치 지원: 키보드/패드 대신 마우스 한 개 또는 음성만으로도 플레이 가능하게 합니다. 실제로 현대 많은 게임들은 컨트롤 커스터마이징과 음성 명령 등을 지원하여 다양한 신체 조건의 플레이어를 포용하고 있습니다
testdevlab.com
. 본 게임도 얼굴 표정, 머리 움직임, 음성 명령 등 여러 입력 수단을 게임 동작에 매핑할 수 있게 할 예정입니다
playability.gg
.
리맵핑과 사용자 설정: 사용자별 맞춤 키 설정을 제공하여, 게임 내 모든 액션에 대해 플레이어가 편한 입력을 자유롭게 할당할 수 있도록 설계합니다
testdevlab.com
. 예를 들어 한 손만 사용 가능한 플레이어는 모든 동작을 마우스로 수행하거나, 음성으로 일부 동작을 대체하는 식으로 유연한 조작체계를 갖춥니다.
단순한 인터페이스: 뱀파이어 서바이벌류 게임은 본래 조작이 단순한 것이 강점입니다 (실제 Vampire Survivors 원작도 왼쪽 아날로그 스틱 하나로 이동만 하면 공격은 자동으로 이뤄지는 "원스틱" 게임입니다
gameinformer.com
). 이러한 장르 특성을 살려 최소한의 조작만으로 모든 게임플레이가 가능하도록 디자인합니다
testdevlab.com
. 복잡한 연타나 다수 버튼 입력, 드래그 동작 등을 요구하지 않으며, **단일 입력(device)**으로도 충분히 즐길 수 있게 합니다.
기타 접근성 요소: 주된 초점은 운동 장애(motor impairment) 지원이지만, 가능하면 UI 대비 향상(고대비 모드), 글자 크기 조절, 색약 모드 등도 고려합니다. 접근성은 특정 대상만을 위한 것이 아니라 모든 플레이어에게 이익이 된다는 점을 명심하고 설계에 반영합니다
testdevlab.com
testdevlab.com
. 예컨대 큰 폰트와 명확한 아이콘은 누구에게나 이해를 높여주고, 단순한 조작은 숙련되지 않은 플레이어도 게임을 쉽게 익히도록 도와줄 것입니다.
以上의 원칙을 토대로, 다음 장에서 구체적인 게임 디자인과 조작 방안을 살펴보겠습니다.

게임 디자인 구상
게임 개요: 구현하려는 게임은 탑다운(Top-down) 2D 뱀파이어 서바이벌류 서바이벌 게임입니다. 플레이어 캐릭터는 자동으로 공격하며, 사용자는 캐릭터의 이동과 몇 가지 선택만 담당합니다. 적들은 사방에서 몰려오고, 플레이어는 피하면서 경험치 아이템을 수집해 레벨업하고 무기/능력을 업그레이드합니다. 일정 시간 생존하면 게임이 클리어되는 방식입니다. 조작 최소화: 기본 게임 루프에서 필수적인 조작은 '이동'뿐입니다. 공격은 자동발사로 처리하여 조작 부담을 줄입니다
gameinformer.com
. 이동 또한 WASD 등의 지속 입력 대신, 한 번의 클릭이나 명령으로 방향을 지정하는 방식을 채택합니다. 이렇게 하면 점진적 난이도 상승과 자동 공격 덕분에 조작이 단순해도 게임의 재미와 긴장감은 유지할 수 있습니다. 포인트 앤 클릭 이동: 마우스나 포인팅 디바이스로 목표 지점을 클릭하면 캐릭터가 해당 위치로 이동하는 방식을 기본으로 합니다. 지속적으로 키를 눌러 움직일 필요 없이, 의도한 지점을 찍는 간단한 동작만으로 방향 전환과 이동이 가능합니다. 이 방식은 전통적인 RTS(실시간 전략)나 시뮬레이션 게임에도 사용되는 것으로, 충분히 복잡한 게임도 포인트 앤 클릭 인터페이스 하나만으로 플레이 가능함이 입증되어 있습니다
testdevlab.com
. 또한 Vision Pro 같은 기기에서는 눈으로 보고 손가락 클릭(집기) 제스처만으로 동일한 조작이 이루어지므로, 이러한 시선-핀치 입력 체계와도 자연스럽게 맞물립니다
uploadvr.com
. 다양한 입력 모드 병행: 게임 내 설정에서 아래와 같은 여러 이동 조작 모드 중 사용자가 편한 것을 선택하도록 할 예정입니다:
목표지점 클릭 이동: 앞서 설명한 대로, 한 번 클릭으로 캐릭터가 해당 좌표로 이동합니다. 클릭 입력을 연속으로 하기 어려운 경우, 더블클릭 시 특정 지속 이동 모드로 전환하거나, 한 번 클릭으로 그 방향으로 계속 이동하는 토글 형태도 고려합니다.
포인터 추적 이동: 클릭 자체도 힘든 일부 사용자를 위해, 마우스 포인터 위치를 실시간으로 추적하여 캐릭터가 쫓아가도록 옵션을 둘 수 있습니다. 사용자가 마우스를 (또는 시선을) 움직이는 것만으로 캐릭터가 따라다니며 이동하므로 클릭 동작 없이도 플레이가 가능합니다. (예: 웹캠 헤드트래킹으로 커서를 움직이는 사용자가 음성으로 "클릭"하지 않아도 캐릭터를 움직일 수 있음)
방향 패드 모드: 터치 디바이스나 일부 사용자를 위해 화면 모서리에 가상 조이스틱/방향패드 UI를 배치하는 옵션도 제공합니다. 이는 모바일 플레이 시 친숙한 방식으로, 한 손가락으로 터치하여 드래그하기 어려운 경우 화면의 좌/우/상/하 한쪽을 탭하여 해당 방향으로 이동하게 하는 간략화도 생각해볼 수 있습니다.
업그레이드 선택: 레벨업 시 무기나 능력 선택 UI가 나타나는데, 시간 제한 없이 대기하도록 하여 천천히 선택할 수 있게 합니다. 선택 방법도 포인트 앤 클릭 이외에 음성 명령이나 **키보드 입력(한 손 사용자를 위한 1,2,3키 누르기 등)**을 병행 지원합니다. 예를 들어 음성으로 아이템 이름이나 화면에 표시된 숫자를 말하면 해당 업그레이드를 선택하도록 구현할 수 있습니다. 이렇게 하면 마우스 클릭이 어려운 사용자가 **"하나", "둘"**과 같이 말로 업그레이드를 골라 게임 진행을 이어갈 수 있습니다. 게임 재미 요소: 접근성에 중점을 두면서도 게임의 재미와 깊이를 확보하기 위해 다음을 고려합니다:
다양한 무기와 아이템: 원작처럼 여러 종류의 무기, 아이템, 캐릭터를 추가하여 조합과 성장의 재미를 줍니다. 자동공격이더라도 무기의 특성에 따라 플레이 감각이 달라지므로, 플레이어가 전략적으로 선택하게 만듭니다.
점진적 난이도와 보상: 시간이 지날수록 적이 강해지지만 그만큼 경험치와 보상이 늘어나 도전욕을 자극합니다. 지나치게 쉬워 지루하지 않도록 난이도를 조절하고, 그렇다고 접근성 사용자에게 벽이 되지 않게 난이도 옵션도 제공할 것입니다 (예: 적 체력/속도 조절 옵션).
짧은 세션, 반복 플레이: 10~30분 내외의 러닝타임을 가지는 세션 단위로 게임을 구성하여, 실패해도 금방 재도전하거나 중간에 쉴 수 있게 합니다. 반복 플레이를 통한 영구 업그레이드(메타 진행) 요소도 추가하면 플레이 동기가 높아집니다.
위와 같이 간단하지만 깊이 있는 게임플레이와 최소한의 입력으로 최대한 조작감을 느끼게 하는 디자인을 지향합니다.

지원 입력 방식 상세
접근성을 위해 지원할 입력 방식과 그것을 활용한 조작 아이디어는 아래와 같습니다. 사용자마다 상황이 다르므로, 게임 내 옵션에서 이들 중 복수 선택 또는 병행 사용이 가능하도록 설계합니다 (예: 마우스로 조준 + 음성 클릭).
마우스/포인팅 기기: 포인트 앤 클릭의 기본 수단입니다. 일반 마우스, 트랙패드, 헤드마우스(예: 카메라로 머리 움직임을 추적해 커서 이동), 시선추적 장치 등 커서를 움직일 수 있는 모든 장치를 포함합니다. 클릭이 가능한 경우 클릭으로 이동/선택을 하고, 클릭이 어려운 경우 커서 이동만으로도 조작 가능하도록 앞서 언급한 포인터 추적 이동 모드를 활용합니다. 또한 OS 차원에서 제공되는 **자동 클릭(dwell click)**이나 시선 고정 기능과도 잘 동작하도록, UI 요소에 충분한 크기와 간격을 둡니다.
음성 명령: 음성은 중요한 대체 입력 수단입니다. 웹에서는 Web Speech API를 통해 브라우저 음성인식 기능을 사용하여 구현할 수 있습니다
developer.mozilla.org
. 사용자의 마이크 입력을 받아 미리 정의된 여러 음성 명령을 인식하도록 합니다 (예: "위로", "아래", "공격", "클릭", "정지" 등). 예를 들어 마우스 커서는 움직일 수 있지만 클릭이 힘든 사용자가 "클릭"이라고 말하면 현재 가리키는 위치를 클릭한 것으로 처리할 수 있습니다. 혹은 음성만으로 플레이하는 사용자를 위해 "왼쪽/오른쪽/위/아래 이동" 명령으로 캐릭터 방향을 지정하고 **"정지"**라고 하면 멈추게 할 수 있습니다. Web Speech API는 현대 브라우저에서 비교적 잘 지원되며, 특히 음성인식은 다양한 접근성 시나리오에서 새로운 제어 수단으로 각광받고 있습니다
developer.mozilla.org
. (단, iOS Safari 등 일부 브라우저에서는 실험적 지원일 수 있으므로, 이를 쓸 수 없는 환경에 대비해 OS 자체 음성제어 기능 사용을 안내하거나 추후 지원 시 업데이트할 계획입니다.)
표정 인식/머리 움직임: 카메라를 통해 사용자의 얼굴 표정이나 머리 자세를 인식하여 입력으로 활용하는 방법입니다. 예컨대 웃기, 입 벌리기, 눈썹 올리기, 고개 좌우 돌리기 등을 각각 특정 게임 동작에 매핑할 수 있습니다. 실제로 playAbility 등의 상용 소프트웨어는 웹캠만으로 50가지 이상의 표정과 머리 움직임을 감지해 임의의 게임 명령에 바인딩하도록 지원하고 있습니다
playability.gg
. 우리 게임에서도 오픈소스 라이브러리(예: MediaPipe Face Mesh, TensorFlow.js의 face-landmarks-detection 등)를 활용해 간단한 표정 두세 가지를 인식해 **"스마일 = 클릭"**과 같이 매핑하는 기능을 실험해볼 수 있습니다. 다만 이는 개발 난이도가 높으므로 선택적 부가기능으로 고려하며, 핵심 플레이에는 필수적이지 않게 설계합니다. 머리 움직임의 경우, PC 사용자는 웹캠으로 머리 방향을 추적하거나, **iPhone의 얼굴 추적(ARKit)**을 활용하는 방법도 있습니다. 다른 한편, 이미 운영체제 차원에서 제공되는 머리/눈 제어 (예: iOS의 스위치 제어에서 머리를 좌우로 돌리면 좌클릭/우클릭으로 매핑하는 기능 등)와 충돌 없이 함께 사용될 수 있게 하는 것도 유의해야 합니다.
터치 입력 (모바일): 모바일 기기에서는 터치 조작이 기본입니다. 한 손 사용을 가정하여, 한 손가락 탭으로 대부분 조작이 가능하도록 합니다. 드래그보다는 탭/더블탭 위주 인터페이스를 제공하고, UI 버튼들도 화면 하단 등 손이 닿기 쉬운 곳에 배치합니다. 또한 기울기 센서(자이로)를 이용해 기기를 기울여 이동 조작을 보조하는 기능도 생각해볼 수 있습니다. 예를 들어 장치를 살짝 기울이면 캐릭터가 해당 방향으로 움직이게 하여, 손가락을 많이 움직이지 않아도 방향 전환이 이루어지도록 합니다. Apple Vision Pro의 경우 터치 대신 시선 & 손 제스처로 입력되지만, OS가 이를 가상 터치로 처리하므로 기본 마우스 입력과 거의 동일하게 다룰 수 있을 것입니다
uploadvr.com
.
기타 입력장치 및 보조기구: 가능하다면 단일 스위치 입력(하드웨어 버튼 하나로 조작)도 지원될 수 있습니다. 예를 들어 블루투스 버튼이나 sip-and-puff(입김 장치) 등이 스페이스바 키나 마우스 클릭을 에뮬레이트하도록 설정해놓은 경우, 게임에서도 해당 키 하나로 스캔 이동이나 토글 동작을 수행하는 별도의 접근성 모드를 제공할 수 있습니다. 이는 중증 장애인 게이머에게 중요한 옵션으로, 다른 입력을 전혀 쓰지 않고도 한 개 버튼으로 메뉴 항목이나 방향을 순차적으로 선택하도록 UI/UX를 구성하는 방식입니다. 다만 초기 버전에서는 복잡도가 높으므로 우선 위의 주요 방식을 지원한 뒤 향후 업그레이드로 고려합니다.
以上의 입력 방법들은 게임 설정 메뉴에서 개별 사용 여부를 On/Off 할 수 있게 하고, 충돌 없이 병행 가능하도록 합니다. 예컨대 사용자가 "헤드포인터로 커서 이동 + 음성으로 클릭" 조합을 원하면, 둘 다 활성화하여 사용할 수 있어야 합니다. 또한, 입력별로 민감도나 보정 옵션도 제공하여 사용 편의를 높입니다 (예: 음성인식의 경우 명령어 인식률이 낮으면 키워드를 변경하거나 정밀도를 조절, 머리 움직임 인식은 작은 움직임에도 반응할지 임계값 조절 등). 결국 목표는 가능한 모든 입력 수단을 포괄하여, 어떤 사용자라도 자신의 능력에 맞는 방식으로 게임을 컨트롤할 수 있도록 하는 데 있습니다
testdevlab.com
. 예시: 다양한 접근성 설정을 제공하는 게임의 옵션 화면 (자막, 색약 모드, 컨트롤 리맵, 음성 명령 등).

기술 스택 및 구조
이 프로젝트는 웹 기술을 기반으로 개발되므로, 성능과 생산성, 접근성 지원 측면에서 적합한 프레임워크와 도구를 선정해야 합니다.
게임 엔진/프레임워크: 최근 프론트엔드에는 React 등이 유행하고 있지만, 실시간 게임 개발에는 전용 2D 게임 엔진을 사용하는 것이 유리합니다. 웹 기반 2D 엔진으로는 대표적으로 Phaser가 많이 사용됩니다. Phaser는 자바스크립트/타입스크립트 기반의 오픈소스 2D 게임 프레임워크로, 빠른 게임루프와 물리엔진, 충돌처리, 에셋로딩 등 게임 개발에 필요한 기능을 갖추고 있습니다
blog.logrocket.com
. 커뮤니티와 문서도 풍부하여 배우기 쉽고, HTML5 Canvas/WebGL을 활용해 브라우저에서 동작하는 고속의 2D 게임을 만들 수 있습니다
blog.logrocket.com
. Phaser 3 버전은 검증되었고, 향후 경량화된 Phaser 4도 예정되어 있으나 당장 안정성을 위해 Phaser 3를 선택합니다. 대안으로는 Pixi.js(렌더링 전용 엔진에 부가 로직 필요) + 커스텀 구현이나, Unity의 WebGL 내보내기(무겁고 접근성 제어 어려움), Godot의 HTML5 출력(엔진 학습 필요) 등이 있지만, 프로젝트 규모와 웹 친화도를 고려할 때 Phaser가 적절한 선택입니다.
언어 및 구조: TypeScript를 사용하는 것이 좋습니다. 정적 타입으로 인해 코드 품질과 유지보수가 향상되고, AI 코덱스 같은 도구로 코드를 생성할 때도 타입 정보가 있으면 맥락 이해에 도움이 됩니다. 프로젝트 구조는 Phaser 기본 구조(게임 config 설정, 여러 Scene으로 구성 등)를 따르고, 가능하면 코드와 리소스를 모듈화하여 관리합니다. UI 요소(설정 메뉴, 선택 창 등)는 HTML/CSS overlay로 구현하거나, Phaser의 DOM요소 통합 기능을 활용할 수 있습니다. React를 부분적으로 도입한다면 **게임 외부 UI (메인 메뉴나 설정 화면)**를 React 컴포넌트로 만들고, 게임 화면은 <canvas>로 Phaser가 그리는 식으로 병행할 수도 있습니다. 하지만 프로젝트 복잡성을 줄이기 위해 초기에는 Phaser만으로 구현하고, 필요시 간단한 HTML 요소를 Phaser 상에 올리는 방식을 택합니다.
음성 인식: 웹에서 음성인식을 사용하려면 Web Speech API의 SpeechRecognition 인터페이스를 사용합니다
developer.mozilla.org
. 자바스크립트로 SpeechRecognition 객체를 생성하고, start()로 음성 캡처를 시작하면 브라우저의 음성 엔진(예: Chrome에선 구글 서버, Safari에선 Siri 엔진 등)이 동작합니다
developer.mozilla.org
. 인식된 텍스트는 이벤트를 통해 콜백으로 받을 수 있으므로, 이를 게임 로직에 연결하면 됩니다. 예를 들어 "click"이라는 단어를 인식하면 현재 커서 위치에서 마우스 클릭 이벤트를 발생시키거나, "up"이라고 들리면 캐릭터를 위쪽으로 이동시킨다든지의 매핑을 구현할 수 있습니다. 또, 다국어 지원도 고려하여 한국어 명령("위", "아래", "공격") 뿐 아니라 영어 등도 인식 가능하게 할 수 있습니다. Web Speech API는 크롬, 엣지, 사파리 등 현대 브라우저에서 사용 가능하지만, 사파리 iOS에서는 작동 방식이 조금 다를 수 있으므로(일부 prefix webkitSpeechRecognition 필요 등) 코드에 폴리필/예외 처리를 합니다. 인식된 음성은 게임 내에서는 일종의 가상 입력 이벤트로 변환하여, 다른 입력 방식과 공통 처리 루틴을 거치도록 설계합니다.
웹캠 및 센서: 표정/머리 인식을 위해서는 getUserMedia API로 카메라 스트림을 받아와 컴퓨터 비전 알고리즘을 적용해야 합니다. 라이브러리로는 Google MediaPipe의 Face Mesh (브라우저용 WASM)나, face-api.js(딥러닝 모델로 얼굴 랜드마크 검출) 등을 사용할 수 있습니다. 예를 들어 MediaPipe Face Mesh를 사용하면 얼굴의 주요 포인트들 (눈, 코, 입 위치 등)을 실시간으로 얻을 수 있고, 입이 크게 벌어졌는지, 고개 각도가 얼마나 기울었는지 등을 계산할 수 있습니다. 이러한 데이터로부터 특정 임계값 이상이면 해당 입력이 발생한 것으로 처리합니다. 처리 주기는 게임 프레임과 별도로 웹워커나 별도 타이머로 두어도 되고, 프레임당 한 번씩 해도 무방합니다. 단, 성능 이슈가 있을 수 있으니 저사양 기기에서는 이 기능을 비활성화하거나, 낮은 해상도 카메라 피드로 처리하는 등 최적화가 필요합니다. 모바일의 기울기 제어는 DeviceMotionEvent로 폰의 가속도/자이로 값을 읽어 구현하며, Vision Pro와 같은 AR기기의 경우 WebXR까지 가지 않더라도 기본적으로 사파리에서 시선-핀치 입력을 마우스 이벤트로 처리해줄 것이므로 큰 추가 개발 없이 동작할 것으로 예상합니다
uploadvr.com
.
데이터 관리: 게임 내 진행상황(예: 영구 업그레이드, 설정 옵션)은 로컬 스토리지나 IndexedDB 등을 이용해 브라우저에 저장합니다. 별도 서버 백엔드는 현재는 필요 없으므로 순수 프론트엔드로 완결되는 구조입니다. (멀티플레이나 온라인 랭킹 등을 추후 추가한다면 서버 요소 고려)
사운드 및 그래픽: Phaser에서 사운드 재생은 Web Audio API 기반으로 제공되므로 그것을 활용하고, 시각적 효과는 Canvas/WebGL로 렌더링됩니다. 접근성을 위해 음량 조절 및 자막/텍스트 표시 기능도 넣을 수 있습니다 (예: 효과음을 글자로 표시하는 옵션 등은 추후 고려).
버전관리: Git 기반으로 프로젝트를 관리하고, GitHub 등을 통해 협업/버전관리를 합니다. 이때 AI 코덱스를 활용해 코드를 생성한다면, 주기적으로 사람이 코드 품질과 주석을 점검하고 커밋 메세지에 변경사항을 잘 기록해 둡니다.
요약하면, Phaser + TypeScript 조합 위에 **Web API들(음성, 카메라, 센서)**를 필요한 만큼 통합하는 기술 스택을 사용하며, 웹 표준 기술을 최대한 활용하여 설치나 플러그인 없이 URL 하나로 실행되는 게임으로 만듭니다.

개발 단계별 계획
이 섹션에서는 프로젝트를 실제로 구현하고 배포하기까지의 과정을 단계별로 나누어 제시합니다. 각 단계는 순차적으로 진행되지만, 필요에 따라 반복적 개선이 이뤄질 수 있습니다 (예: 기능 구현 후 테스트 및 피드백 반영).
프로젝트 설정 및 환경 구성: 개발을 시작하기에 앞서 Git 저장소를 만들고, TypeScript + Phaser 환경을 구성합니다. Node.js 기반으로 프로젝트 스캐폴딩을 한 후 Phaser를 npm으로 설치하거나 CDN으로 불러옵니다. 로컬 서버를 띄워 바로 개발 중에 플레이 해볼 수 있는 환경을 마련하고, 화면에 간단한 테스트 스프라이트 하나 띄워보는 것으로 세팅을 검증합니다. 또한 Lint/포매터 설정, 간단한 README 작성, 그리고 접근성 관련 테스트 플랜 수립도 이 단계에서 병행합니다.
기본 게임 플레이 구현: 캐릭터, 적, 충돌, 공격 등 게임의 최소한의 동작을 구현합니다. 예를 들어:
화면 중앙에 플레이어 캐릭터 스프라이트 표시, 기본 이동 속도 적용.
일정 주기로 주변에 적 스폰 및 적들이 플레이어를 향해 이동 혹은 화면 특정 방향에서 몰려오도록 구현.
플레이어의 자동 공격: 일정 시간마다 원형 범위 내의 적들에게 데미지 또는 투사체 발사 등 (우선은 단순하게).
체력/경험치 시스템: 적 처치 시 경험치 오브젝트 생성, 플레이어 획득 시 경험치 증가 및 경험치바(UI) 표시.
레벨 업 및 업그레이드: 경험치가 일정치 차면 레벨업 이벤트 발생, 간단한 업그레이드 선택 UI 팝업 (예: 세 가지 중 무작위 선택지). 초기 단계에서는 업그레이드 종류를 2~3개만 두고 작동 여부만 테스트합니다.
게임 승패 조건: 임의로 5분 또는 특정 레벨 도달 시 승리, 플레이어 체력 소진 시 패배 처리 등 임시로라도 구현해 둡니다.
이 단계까지는 조작은 키보드나 기본 마우스로 편하게 테스트하면서 진행합니다. 게임 루프와 객체 관리가 제대로 되는지, 성능은 적절한지 (적 수 증가 시 프레임 확인) 등을 점검합니다.
포인트 앤 클릭 이동 구현: 마우스 클릭으로 캐릭터 이동하는 기능을 추가합니다. 구체적으로, 클릭한 지점을 향해 플레이어 캐릭터가 등속도로 이동하고, 거의 근처에 도달하면 정지하도록 합니다. 경로finding이 필요한 복잡한 지형은 없으므로 직선 이동即可ですが, 장애물이 있다면 간단한 피격 판정이나 우회 로직을 추후 고려합니다. 또한, 포인터 위치 추적 모드도 함께 구현해 옵션으로 넣습니다. 이것은 매 프레임 마우스 커서 좌표를 읽어, 캐릭터가 해당 좌표쪽으로 조금씩 움직이게 하는 것입니다. 두 모드 간 전환 옵션을 게임 설정에 추가하고, 일단 디폴트는 클릭 투 무브로 설정합니다. 구현 후에는 마우스만으로 충분히 플레이어가 움직이고 적을 피할 수 있는지 플레이 테스트를 합니다.
음성 명령 통합: Web Speech API를 이용하여 음성 입력 시스템을 구축합니다. 브라우저 호환성을 위해 window.SpeechRecognition과 window.webkitSpeechRecognition를 모두 확인하고 객체 생성
developer.mozilla.org
, 한국어 인식을 위해 lang 속성을 ko-KR로 설정 (또는 다국어 지원 방법 모색)합니다. 우선 PTT(Push-to-talk) 방식으로 시작하여, 사용자가 어떤 조작으로 음성인식을 활성화할지 정합니다. 예를 들어 키보드의 V키 누름이나 화면 UI 버튼 토글로 음성 인식을 시작/중지하게 하여, 상시 마이크를 켜두지 않도록 합니다 (노이즈 환경 대비). 음성 명령어 리스트와 그에 대응하는 게임 동작 매핑을 정의합니다. 예시:
"시작" → 게임 시작 (메인 메뉴 등에서)
"정지" 또는 "멈춰" → 캐릭터 움직임 정지 (혹은 일시정지)
방향: "위/아래/왼쪽/오른쪽" → 해당 방향으로 일정 시간 or 일정 거리 이동 명령. 이때 연속 이동이 필요하면, "계속 위" 등으로 세분화하거나 한 번 명령 시 몇 초간 움직이게 할지 결정.
"공격" → (현재는 자동공격이므로 필요 없지만, 특별스킬이 있다면 발동에 사용)
"클릭" → 현재 커서 위치에 클릭 이벤트 발생 (업그레이드 선택 등 UI에서 활용)
숫자: "하나/둘/셋" 또는 "1번/2번" → 업그레이드 선택 메뉴에서 각각의 선택지에 매핑.
기타 게임 메뉴 조작: "다음/이전" 메뉴 항목 이동, "확인" 등 (UI에 포커스 개념을 둘 경우).
음성인식 결과는 연속된 문장으로도 올 수 있으므로, 예를 들어 "위 앞으로"라고 말하면 "위", "앞으로" 두 토큰을 나눠 각각 처리하거나, 미리 정의한 문장 패턴을 인식 grammar로 등록합니다. SpeechRecognition API에는 GrammarList를 정의할 수 있으나 Safari 등 호환을 생각하면 단어 매칭으로 충분히 커버 가능합니다. 이 기능이 완성되면 손을 전혀 쓰지 않고 음성만으로 플레이하는 테스트를 진행합니다. 주변 소음 속에서도 인식률이 괜찮은지, 명령 반응 속도가 게임 흐름에 지장 없는지 확인하고 튜닝합니다. 예컨대 "왼쪽" 명령이 연속으로 잘 들어가지 않으면, 인식 중간에 약간의 지연을 준다든지, 또는 연속 이동 명령 대신 한 번에 약간씩만 움직이게 한다든지 조절합니다.
머리/표정 추적 입력 구현: 선택 기능으로 웹캠을 통한 얼굴 추적 입력을 개발합니다. 이 단계는 난이도가 있으므로 기본 게임이 돌아가는 것을 확인한 후 착수합니다. 먼저 사용자 동의 하에 getUserMedia로 카메라 스트림을 가져옵니다. 그리고 선택한 라이브러리를 적용해 얼굴 특징을 분석합니다. 예를 들어 MediaPipe Face Mesh 사용 시 JavaScript에서 모델 로딩하고, 각 프레임마다 predict를 호출해 얼굴 랜드마크 468개 점 좌표를 얻습니다. 여기서 양쪽 눈이 감겼는지(눈 주변 점들의 거리로 판정), 입이 열렸는지(입술 점들 사이 거리), 고개 기울기(코나 귀점의 상대 위치) 등을 계산합니다. 그리고 게임 설정에서 사용자 캘리브레이션 단계를 거칠 수 있게 합니다. 예를 들어 "기본 표정 캡처 -> 웃어보기 -> 고개 좌로 기울이기" 등의 동작을 통해 사용자마다 표정 인식 기준을 자동 설정하게 합니다 (사람마다 얼굴 크기나 기본 표정이 다르므로). 매핑 예시로는:
"고개 왼쪽 기울임" = 캐릭터 좌측 이동 지속 (기울이는 동안 계속 이동)
"고개 오른쪽 기울임" = 캐릭터 우측 이동
"눈 오래 감기" = 일시정지 토글 (눈 깜빡임은 실수 많을 수 있어 길게 감음으로)
"입 크게 벌리기" = 마우스 클릭 (또는 폭탄같은 특수공격 사용)
이러한 매핑은 사용자 편의에 따라 바꿀 수 있도록 UI 제공도 고려합니다. 기술 구현 완료 후, 실제로 손과 목을 전혀 쓰지 않고 머리/표정만으로 캐릭터 이동과 간단한 선택이 가능한지 테스트합니다. 이 기능은 모든 사용자가 쓰는 건 아니므로 실험적 옵션 형태로 제공하고, 성능 문제가 있으면 기본 off로 두는 등 신중히 다룹니다.
UI 및 UX 개선: 게임의 사용자 인터페이스 전반을 정비합니다. 접근성 옵션 메뉴를 만들어 지금까지 구현된 모든 입력 방법을 オン/オフ 할 수 있게 하고, 각 옵션 옆에 사용 방법을 설명하는 툴팁이나 안내를 첨부합니다. 예를 들어 "음성 명령 – 마이크 아이콘 클릭 시 활성화. 예시 명령: '위', '클릭'..." 이런 식입니다. 폰트 크기 조절 옵션, 음량 조절, 그래픽 품질(저사양 모드) 등도 이 시점에 함께 넣습니다. HUD 요소 (체력바, 경험치바, 타이머 등)는 충분히 크고 명확하게 디자인하고, 색상은 고대비 테마를 추가로 만들어 색약 모드나 어두운 배경에서 더 잘 보이도록 합니다. 또한 튜토리얼 또는 가이드 제공을 고려합니다. 첫 플레이 시 간단한 안내를 띄워 각종 옵션과 조작법을 소개하고, 사용자가 직접 조작 연습을 해볼 수 있는 안전한 환경(예: 적 등장 안 하고 천천히 명령어 따라 해보기)을 제공합니다. 이는 인지나 학습 측면에서 도움이 되어 초보자나 일부 인지장애가 있는 플레이어도 게임에 익숙해질 수 있습니다. 참고로 명확한 튜토리얼과 유연한 난이도는 접근성 디자인의 모범 사례입니다
testdevlab.com
testdevlab.com
.
멀티 플랫폼 테스트: 이제 게임이 데스크톱 크롬 등 개발 환경에서는 잘 동작한다고 가정하고, 다양한 기기에서의 테스트를 진행합니다. 우선 PC 환경에서:
키보드/마우스만 사용하는 경우 정상 플레이 확인.
마우스 없이 음성만 사용하는 시나리오 테스트 (마우스 커서를 움직일 수 없는 사용자를 가정, 음성 명령으로 이동/클릭 수행).
헤드포인터 (예: Windows에서 카메라 헤드마우스 소프트웨어 사용 또는 Mac에서 머리 포인터 기능 활성)로 커서 이동 + 음성 클릭 조합 테스트.
한 손 모드: 마우스만 또는 키보드만으로 플레이 가능한지(키보드 하나로도 움직이게 임시 지원해볼 수 있음) 등.
화면읽기 지원: 시각장애인을 주요 타겟으로 하진 않지만, 메뉴나 텍스트는 스크린리더가 읽을 수 있도록 aria-label 등을 붙여 웹 접근성 준수 여부를 확인.
다음으로 모바일 기기 테스트:
Android 스마트폰 (Chrome, 삼성 인터넷 등)에서 터치 조작 및 음성 동작 확인.
iPhone/iPad (Safari)에서의 호환성 확인: 특히 Web Speech API 음성인식이 iOS 16+ 사파리에서 prefix로 지원되는지, 마이크 권한 이슈 등 체크.
터치로 UI 조작이 편한지, 작은 화면에서 요소가 너무 작지 않은지 등 UX 확인. 필요하면 반응형 디자인 조정.
기기 성능이 낮아도 돌아가도록, 저사양 기기에서 프레임이 떨어지면 적 수나 이펙트를 자동 조절하는 기능도 고려.
그리고 Vision Pro 등 AR/VR 기기 테스트:
Vision Pro 기기는 실제로 사용해보면서, Safari에서 게임을 켜고 시선으로 커서 이동 + 손가락 pinch로 클릭하여 플레이가 되는지 확인합니다. (Apple의 VisionOS Safari는 WebXR 모드가 아니더라도 기본적으로 눈 가리키는 곳을 가상 커서로 취급하고 손 제스처를 클릭으로 매핑할 가능성이 높습니다
uploadvr.com
.)
만약 기본모드에서 안 된다면, WebXR을 활성화하여 transient-pointer 입력으로 동작시킬 수도 있지만, 가급적 추가 API 없이도 플레이 가능하도록 설계된 만큼 기본 설정으로 실험합니다.
VR 모드가 주는 특수한 이슈(예: 화면 크기, 해상도, 입력 지연 등)를 관찰하고 필요 시 조정합니다.
다양한 환경에서 발견된 버그나 불편사항을 수집하고 수정합니다. 특히 접근성 기능들은 여러 조합으로 쓰일 수 있으므로 예기치 않은 상호작용(예: 음성인식 중인데 다른 입력이 동시에 들어와 오작동)은 없는지 꼼꼼히 테스트합니다.
게임 완성도 향상: 게임의 콘텐트를 보강하고, 재미 요소를 최종 점검합니다. 플레이 밸런스를 조절하여 너무 쉽거나 어렵지 않게 하고, 다양한 전략이 가능하도록 무기/업그레이드의 효과를 튜닝합니다. 그래픽이나 사운드도 필요한 최소한의 퀄리티를 갖추도록 무료 에셋이나 직접 만든 간단한 이미지를 적용합니다. 필요하다면 장애인 커뮤니티나 지인 등에게 피드백을 받아 접근성 측면에서 개선할 점을 찾습니다. 이 단계에서는 작은 디테일 (예: 피격 시 화면 흔들림 효과를 켜고끄는 옵션, 색상 대비, UI 글씨 표현 등)들을 다듬어서 폴리싱(polishing) 작업을 합니다.
특히 게임의 재미에 직결되는 부분을 체크합니다. "이동하며 자동으로 쏘는" 플레이가 단조롭지 않도록 적 패턴을 다양화하거나, 짧은 퀘스트 같은 목표를 부여할 수 있습니다. 접근성을 해치지 않는 선에서 **도전과제(achievements)**나 점수 시스템을 넣어 리플레이 가치를 높입니다.
또한 세이브/로드나 일시정지 등 기본 편의 기능도 확인합니다. 접근성이 필요한 유저일수록 일시정지 기능은 중요하므로, 언제든 게임을 멈추고 쉴 수 있게 보장합니다.
배포 준비: 게임이 충분히 완성되었다면, 웹에 배포하여 다른 사람들도 플레이할 수 있게 합니다. 배포를 위해 프로젝트를 정적 웹 페이지 형태로 빌드합니다 (HTML, JS, CSS와 에셋 파일들). 손쉽고 유명한 무료 배포 서비스로 itch.io를 추천합니다. itch.io는 인디 게임을 무료로 배포하기에 최적화된 플랫폼으로, 간단히 zip 파일을 업로드하는 것만으로 브라우저에서 바로 플레이 가능한 페이지를 만들 수 있습니다
itch.io
itch.io
. 가입 후 "Upload Game" 옵션으로 빌드 결과물을 올리고, "HTML5 (Play in browser)" 옵션을 선택하면 누구나 플레이할 수 있는 웹페이지가 생성됩니다. itch.io는 스크린샷 업로드, 설명 작성, 공개/비공개 설정 등도 제공하므로 프로젝트 소개를 함께 작성합니다. 이외에도 GitHub Pages, Netlify, Vercel 등도 무료 호스팅이 가능하므로, 동시에 소스 코드를 GitHub에 공개하고 Pages를 통해 플레이 링크를 제공할 수도 있습니다. (GitHub Pages의 경우 정적 사이트로 배포하며, 도메인도 사용자명이 포함된 URL이 부여되고, Netlify/Vercel은 저장소와 연동해 자동 배포하기 편리합니다
dev.to
.) 배포 후엔 직접 여러 기기에서 웹배포 버전을 실행해보고, 배포 환경에서 추가로 발생하는 이슈(경로 문제, 케이스 민감, 모바일에서 화면 잠김 등)를 해결합니다.
마지막 점검 및 커뮤니티 공유: 실제 배포 링크를 지인들과 커뮤니티(예: 접근성 관련 포럼, Reddit의 /r/disabledgamers 등)에 공유하여 피드백을 받습니다. 플레이어들이 재미있어 하는지, 어떤 접근성 옵션을 주로 사용하는지, 추가로 바라는 기능이나 불편은 없는지 의견을 수렴합니다. 이를 토대로 작은 업데이트를 이어가며 게임을 개선하거나, 향후 프로젝트에 교훈으로 삼습니다. 완성된 프로젝트의 코드와 문서를 정리하여 AGENTS.md와 같은 형식으로도 보관해 둡니다. (AGENTS.md에는 본 기획 내용과 함께 실제 구현상 어려웠던 점, 해결 방법, 추후 아이디어 등을 적어두면 향후 AI 코딩 에이전트가 코드 개량을 할 때 도움을 줄 수 있습니다.)

무료 배포 이후 계획 (추가 가능 사항)
취미 프로젝트이지만 실제로 공개 배포까지 염두에 두었기 때문에, 이후 여력이 있다면 다음과 같은 발전도 고려할 수 있습니다:
지속적인 접근성 업데이트: 플레이어들의 피드백을 받아 더 다양한 보조장치와의 연동을 추가합니다. 예를 들어 Xbox 적응형 컨트롤러나 시리 제어, 스위치 제어 사용자들을 위한 세부 옵션을 늘립니다. 또한 자동화 스크립팅(매크로) 기능을 넣어 복잡한 조작을 한 번의 입력으로 수행하거나, Co-Pilot 모드(두 사람이 하나의 캐릭터를 함께 조작, 예: 한 명은 이동만, 다른 한 명은 입력 보조)를 지원하면 도움이 될 것입니다
testdevlab.com
.
컨텐츠 확장: 새로운ステージや敵、武器などを追加し、ゲームのボリュームを増やします. 定期的なアップデートでユーザーの興味を保ちます (원작 Vampire Survivors도 무료 업데이트로 콘텐츠를 확장하며 흥미를 지속시켰습니다).
멀티플레이 모드: 기술적으로 도전이지만, 협力 멀티플레이나 경쟁 모드를 추가하면 더 넓은 유저층을 유인할 수 있습니다. 이때도 접근성을 위해 매치메이킹 필터(예: 보조모드 사용하는 유저들끼리 매칭)나 핑(통신지연) 허용 범위 등을 조정할 필요가 있습니다.
모바일 앱 패키징: 웹앱을 그대로 iOS/안드로이드 앱으로 포팅하여 앱스토어에 배포할 수도 있습니다 (Phaser의 Cordova 또는 Capacitor 통합을 활용). 다만 앱스토어는 접근성 심사 기준이 있을 수 있으므로(특히 Apple은 VoiceOver 대응 등 확인), 웹에서 어느 정도 ARIA 적용 등을 해두면 도움이 됩니다.
오픈소스화: 프로젝트를 오픈소스로 GitHub에 공개하여 다른 개발자들이 함께 개선하도록 독려할 수 있습니다. 이를 통해 예상치 못한 접근성 아이디어나 코드 개선점을 얻을 수 있고, 더불어 접근성 게임 개발의 사례 연구로 가치가 있습니다.
以上をもって, 접근성을 최우선으로 고려한 뱀파이어 서바이벌류 게임 개발 계획을 마칩니다. 이 계획은 코드 구현을 도와주는 AI에게 명세를 전달하거나, 함께 일하는 팀원들과 공유하는 설계 문서로 활용할 수 있습니다. 실제 구현 시에는 예상치 못한 기술적 문제도 나오겠지만, 유연하게 대처하면서 모든 사람이 즐길 수 있는 재미있는 게임을 만드는 것을 최종 목표로 삼겠습니다. 참고 및 출처: 접근성 게임 디자인 및 웹 기술에 관한 최신 자료들을 참조하여 계획을 수립했습니다. 특히 TestDevLab의 게임 접근성 가이드
testdevlab.com
testdevlab.com
, Mozilla MDN의 Web Speech API 문서
developer.mozilla.org
, playAbility의 적응형 게이밍 소개
playability.gg
, LogRocket의 HTML5 게임 엔진 비교
blog.logrocket.com
, Apple Vision Pro 웹 기술 기사
uploadvr.com
, itch.io 배포 안내
itch.io
 등을 참고했습니다.
인용

WebXR Now Supports Apple Vision Pro Default Input System

https://www.uploadvr.com/webxr-apple-vision-pro-input-system/

How to Achieve Video Game Accessibility

https://www.testdevlab.com/blog/video-game-accessibility-testing

playAbility Adaptive Software - Accessible Gaming for All

https://www.playability.gg/

Vampire Survivors Review - Single-Stick Masterpiece - Game Informer

https://gameinformer.com/review/vampire-survivors/single-stick-masterpiece

How to Achieve Video Game Accessibility

https://www.testdevlab.com/blog/video-game-accessibility-testing

How to Achieve Video Game Accessibility

https://www.testdevlab.com/blog/video-game-accessibility-testing

How to Achieve Video Game Accessibility

https://www.testdevlab.com/blog/video-game-accessibility-testing

Using the Web Speech API - Web APIs | MDN

https://developer.mozilla.org/en-US/docs/Web/API/Web_Speech_API/Using_the_Web_Speech_API

Best JavaScript and HTML5 game engines (updated for 2025) - LogRocket Blog

https://blog.logrocket.com/best-javascript-html5-game-engines-2025/

Using the Web Speech API - Web APIs | MDN

https://developer.mozilla.org/en-US/docs/Web/API/Web_Speech_API/Using_the_Web_Speech_API

Using the Web Speech API - Web APIs | MDN

https://developer.mozilla.org/en-US/docs/Web/API/Web_Speech_API/Using_the_Web_Speech_API

Using the Web Speech API - Web APIs | MDN

https://developer.mozilla.org/en-US/docs/Web/API/Web_Speech_API/Using_the_Web_Speech_API

How to Achieve Video Game Accessibility

https://www.testdevlab.com/blog/video-game-accessibility-testing

How to Achieve Video Game Accessibility

https://www.testdevlab.com/blog/video-game-accessibility-testing

Sell your indie games online - itch.io

https://itch.io/developers

Sell your indie games online - itch.io

https://itch.io/developers

10 Free Web Hosting Solutions for Static and Dynamic Sites

https://dev.to/anticoder03/10-free-web-hosting-solutions-for-static-and-dynamic-sites-48g1

How to Achieve Video Game Accessibility

https://www.testdevlab.com/blog/video-game-accessibility-testing
모든 출처

uploadvr

testdevlab

playability

gameinformer

developer.mozilla

blog.logrocket

itch

dev

## 최근 변경 요약 (2025-09-13)

- 연습 모드(튜토리얼) 흐름 개선: 연습 시작 시 스폰 일시정지, 제한된 적 팩(6마리)만 소환, 모두 처치하면 자동으로 본 게임으로 전환됩니다.
- 적 추적 AI 수정: 적이 스폰 시점의 위치가 아닌, 플레이어의 현재 위치를 지속적으로 추적하도록 매 프레임 속도를 갱신합니다.
- 러닝 타이머 추가: 기본 90초(스테이지에 따라 약간 증가). 시간 초과 또는 패배 시 런이 명확히 종료됩니다.
- 런 종료 화면(“Run Complete”) 추가: 생존 시간/처치 수/레벨 요약과 함께 토큰 보상(레벨업 보상과는 별도)을 지급합니다.
- 스테이지 진행(백엔드 없음): 토큰(로컬 저장소)에 따라 다음 스테이지를 해금하고 진행할 수 있습니다. 해금 비용은 대략 3 + 2×(현재 스테이지−1).
- 접근성 유지/강화: 기존 스캔/드웰, 보이스, 포인터‑팔로우/클릭‑투‑무브와 호환되도록 모든 오버레이(시작/설정/레벨업/런 종료)가 DOM/ARIA로 제공됩니다.

개발자 참고
- 진행 상태 저장 키: `limitless:progress:v1` (현재 스테이지, 최고 해금 스테이지, 토큰 수).
- 설정 저장 키: `limitless:settings:v1`.
- 진행 리셋: 브라우저 콘솔에서 `localStorage.removeItem('limitless:progress:v1')` 실행.
- 주요 파일:
  - `game/src/game/scenes/GameScene.ts`: 연습 모드 처리, 적 추적, 러닝 타이머/종료 이벤트 발행(`runover:open`).
  - `game/src/state/progress.ts`: 진행(스테이지/토큰) 로컬 저장.
  - `game/src/main.ts`: 런 종료 오버레이 UI/버튼, 스캔 모드 연동.
  - `game/index.html`: Run Complete 오버레이 마크업 추가.
  - `game/README.md`: 배포/조작/메타 진행 설명 업데이트.
